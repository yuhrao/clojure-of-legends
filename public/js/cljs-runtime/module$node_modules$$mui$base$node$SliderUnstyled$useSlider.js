shadow$provide.module$node_modules$$mui$base$node$SliderUnstyled$useSlider=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function asc(a,b){return a-b}function clamp(value,min,max){return null==value?min:Math.min(Math.max(min,
value),max)}function findClosest(values,currentValue){var _values$reduce;({index:values}=null!=(_values$reduce=values.reduce((acc,value,index)=>{value=Math.abs(currentValue-value);return null===acc||value<acc.distance||value===acc.distance?{distance:value,index}:acc},null))?_values$reduce:{});return values}function trackFinger(event,touchId){if(void 0!==touchId.current&&event.changedTouches){for(let i=0;i<event.changedTouches.length;i+=1){const touch=event.changedTouches[i];if(touch.identifier===
touchId.current)return{x:touch.clientX,y:touch.clientY}}return!1}return{x:event.clientX,y:event.clientY}}function valueToPercent(value,min,max){return 100*(value-min)/(max-min)}function setValueIndex({values,newValue,index}){values=values.slice();values[index]=newValue;return values.sort(asc)}function focusThumb({sliderRef,activeIndex,setActive}){var _sliderRef$current,_doc$activeElement;const doc=(0,_utils.unstable_ownerDocument)(sliderRef.current);if(null==(_sliderRef$current=sliderRef.current)||
!_sliderRef$current.contains(doc.activeElement)||Number(null==doc?void 0:null==(_doc$activeElement=doc.activeElement)?void 0:_doc$activeElement.getAttribute("data-index"))!==activeIndex){var _sliderRef$current2;null==(_sliderRef$current2=sliderRef.current)?void 0:_sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus()}setActive&&setActive(activeIndex)}function doesSupportTouchActionNone(){void 0===cachedSupportsTouchActionNone&&(cachedSupportsTouchActionNone="undefined"!==
typeof CSS&&"function"===typeof CSS.supports?CSS.supports("touch-action","none"):!0);return cachedSupportsTouchActionNone}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports.Identity=void 0;exports.default=function(parameters){const {"aria-labelledby":ariaLabelledby,defaultValue,disabled=!1,disableSwap=!1,isRtl=!1,marks:marksProp=!1,max=100,min=0,name,onChange,onChangeCommitted,orientation="horizontal",ref,
scale=Identity,step=1,tabIndex,value:valueProp}=parameters,touchId=React.useRef(),[active,setActive]=React.useState(-1),[open,setOpen]=React.useState(-1),[dragging,setDragging]=React.useState(!1),moveCount=React.useRef(0),[valueDerived,setValueState]=(0,_utils.unstable_useControlled)({controlled:valueProp,default:null!=defaultValue?defaultValue:min,name:"Slider"}),handleChange=onChange&&((event,value,thumbIndex)=>{event=event.nativeEvent||event;event=new event.constructor(event.type,event);Object.defineProperty(event,
"target",{writable:!0,value:{value,name}});onChange(event,value,thumbIndex)}),range=Array.isArray(valueDerived);let values=range?valueDerived.slice().sort(asc):[valueDerived];values=values.map(value=>clamp(value,min,max));const marks=!0===marksProp&&null!==step?[...Array(Math.floor((max-min)/step)+1)].map((_,index)=>({value:min+step*index})):marksProp||[],marksValues=marks.map(mark=>mark.value),{isFocusVisibleRef,onBlur:handleBlurVisible,onFocus:handleFocusVisible,ref:focusVisibleRef}=(0,_utils.unstable_useIsFocusVisible)(),
[focusedThumbIndex,setFocusedThumbIndex]=React.useState(-1),sliderRef=React.useRef();var handleFocusRef=(0,_utils.unstable_useForkRef)(focusVisibleRef,sliderRef);const handleRef=(0,_utils.unstable_useForkRef)(ref,handleFocusRef),createHandleHiddenInputFocus=otherHandlers=>event=>{var _otherHandlers$onFocu;const index=Number(event.currentTarget.getAttribute("data-index"));handleFocusVisible(event);!0===isFocusVisibleRef.current&&setFocusedThumbIndex(index);setOpen(index);null==otherHandlers?void 0:
null==(_otherHandlers$onFocu=otherHandlers.onFocus)?void 0:_otherHandlers$onFocu.call(otherHandlers,event)},createHandleHiddenInputBlur=otherHandlers=>event=>{var _otherHandlers$onBlur;handleBlurVisible(event);!1===isFocusVisibleRef.current&&setFocusedThumbIndex(-1);setOpen(-1);null==otherHandlers?void 0:null==(_otherHandlers$onBlur=otherHandlers.onBlur)?void 0:_otherHandlers$onBlur.call(otherHandlers,event)};(0,_utils.unstable_useEnhancedEffect)(()=>{if(disabled&&sliderRef.current.contains(document.activeElement)){var _document$activeEleme;
null==(_document$activeEleme=document.activeElement)?void 0:_document$activeEleme.blur()}},[disabled]);disabled&&-1!==active&&setActive(-1);disabled&&-1!==focusedThumbIndex&&setFocusedThumbIndex(-1);const createHandleHiddenInputChange=otherHandlers=>event=>{var _otherHandlers$onChan;null==(_otherHandlers$onChan=otherHandlers.onChange)?void 0:_otherHandlers$onChan.call(otherHandlers,event);_otherHandlers$onChan=Number(event.currentTarget.getAttribute("data-index"));var value=values[_otherHandlers$onChan],
marksIndex=marksValues.indexOf(value);let newValue=event.target.valueAsNumber;marks&&null==step&&(newValue=newValue<value?marksValues[marksIndex-1]:marksValues[marksIndex+1]);newValue=clamp(newValue,min,max);marks&&null==step&&(value=marksValues.indexOf(values[_otherHandlers$onChan]),newValue=newValue<values[_otherHandlers$onChan]?marksValues[value-1]:marksValues[value+1]);range&&(disableSwap&&(newValue=clamp(newValue,values[_otherHandlers$onChan-1]||-Infinity,values[_otherHandlers$onChan+1]||Infinity)),
value=newValue,newValue=setValueIndex({values,newValue,index:_otherHandlers$onChan}),marksIndex=_otherHandlers$onChan,disableSwap||(marksIndex=newValue.indexOf(value)),focusThumb({sliderRef,activeIndex:marksIndex}));setValueState(newValue);setFocusedThumbIndex(_otherHandlers$onChan);handleChange&&handleChange(event,newValue,_otherHandlers$onChan);onChangeCommitted&&onChangeCommitted(event,newValue)},previousIndex=React.useRef();let axis=orientation;isRtl&&"horizontal"===orientation&&(axis+="-reverse");
const getFingerNewValue=({finger,move=!1})=>{var {current:slider}=sliderRef;const {width,height,bottom,left}=slider.getBoundingClientRect();finger=0===axis.indexOf("vertical")?(bottom-finger.y)/height:(finger.x-left)/width;-1!==axis.indexOf("-reverse")&&(finger=1-finger);slider=(max-min)*finger+min;if(step){finger=Number;slider=Math.round((slider-min)/step)*step+min;var JSCompiler_temp_const=slider.toFixed;if(1>Math.abs(step)){var JSCompiler_inline_result=step.toExponential().split("e-");const matissaDecimalPart=
JSCompiler_inline_result[0].split(".")[1];JSCompiler_inline_result=(matissaDecimalPart?matissaDecimalPart.length:0)+parseInt(JSCompiler_inline_result[1],10)}else JSCompiler_inline_result=(JSCompiler_inline_result=step.toString().split(".")[1])?JSCompiler_inline_result.length:0;slider=finger(JSCompiler_temp_const.call(slider,JSCompiler_inline_result))}else finger=findClosest(marksValues,slider),slider=marksValues[finger];slider=clamp(slider,min,max);finger=0;range&&(finger=move?previousIndex.current:
findClosest(values,slider),disableSwap&&(slider=clamp(slider,values[finger-1]||-Infinity,values[finger+1]||Infinity)),JSCompiler_temp_const=slider,slider=setValueIndex({values,newValue:slider,index:finger}),disableSwap&&move||(finger=slider.indexOf(JSCompiler_temp_const),previousIndex.current=finger));return{newValue:slider,activeIndex:finger}},handleTouchMove=(0,_utils.unstable_useEventCallback)(nativeEvent=>{const finger=trackFinger(nativeEvent,touchId);if(finger)if(moveCount.current+=1,"mousemove"===
nativeEvent.type&&0===nativeEvent.buttons)handleTouchEnd(nativeEvent);else{var {newValue,activeIndex}=getFingerNewValue({finger,move:!0});focusThumb({sliderRef,activeIndex,setActive});setValueState(newValue);!dragging&&2<moveCount.current&&setDragging(!0);handleChange&&newValue!==valueDerived&&handleChange(nativeEvent,newValue,activeIndex)}}),handleTouchEnd=(0,_utils.unstable_useEventCallback)(nativeEvent=>{var finger=trackFinger(nativeEvent,touchId);setDragging(!1);finger&&({newValue:finger}=getFingerNewValue({finger,
move:!0}),setActive(-1),"touchend"===nativeEvent.type&&setOpen(-1),onChangeCommitted&&onChangeCommitted(nativeEvent,finger),touchId.current=void 0,stopListening())}),handleTouchStart=(0,_utils.unstable_useEventCallback)(nativeEvent=>{if(!disabled){doesSupportTouchActionNone()||nativeEvent.preventDefault();var touch=nativeEvent.changedTouches[0];null!=touch&&(touchId.current=touch.identifier);touch=trackFinger(nativeEvent,touchId);if(!1!==touch){const {newValue,activeIndex}=getFingerNewValue({finger:touch});
focusThumb({sliderRef,activeIndex,setActive});setValueState(newValue);handleChange&&handleChange(nativeEvent,newValue,activeIndex)}moveCount.current=0;nativeEvent=(0,_utils.unstable_ownerDocument)(sliderRef.current);nativeEvent.addEventListener("touchmove",handleTouchMove);nativeEvent.addEventListener("touchend",handleTouchEnd)}}),stopListening=React.useCallback(()=>{const doc=(0,_utils.unstable_ownerDocument)(sliderRef.current);doc.removeEventListener("mousemove",handleTouchMove);doc.removeEventListener("mouseup",
handleTouchEnd);doc.removeEventListener("touchmove",handleTouchMove);doc.removeEventListener("touchend",handleTouchEnd)},[handleTouchEnd,handleTouchMove]);React.useEffect(()=>{const {current:slider}=sliderRef;slider.addEventListener("touchstart",handleTouchStart,{passive:doesSupportTouchActionNone()});return()=>{slider.removeEventListener("touchstart",handleTouchStart,{passive:doesSupportTouchActionNone()});stopListening()}},[stopListening,handleTouchStart]);React.useEffect(()=>{disabled&&stopListening()},
[disabled,stopListening]);const createHandleMouseDown=otherHandlers=>event=>{var _otherHandlers$onMous;null==(_otherHandlers$onMous=otherHandlers.onMouseDown)?void 0:_otherHandlers$onMous.call(otherHandlers,event);if(!disabled&&!event.defaultPrevented&&0===event.button){event.preventDefault();_otherHandlers$onMous=trackFinger(event,touchId);if(!1!==_otherHandlers$onMous){const {newValue,activeIndex}=getFingerNewValue({finger:_otherHandlers$onMous});focusThumb({sliderRef,activeIndex,setActive});setValueState(newValue);
handleChange&&handleChange(event,newValue,activeIndex)}moveCount.current=0;event=(0,_utils.unstable_ownerDocument)(sliderRef.current);event.addEventListener("mousemove",handleTouchMove);event.addEventListener("mouseup",handleTouchEnd)}};handleFocusRef=valueToPercent(range?values[0]:min,min,max);const trackLeap=valueToPercent(values[values.length-1],min,max)-handleFocusRef,createHandleMouseOver=otherHandlers=>event=>{var _otherHandlers$onMous2;null==(_otherHandlers$onMous2=otherHandlers.onMouseOver)?
void 0:_otherHandlers$onMous2.call(otherHandlers,event);event=Number(event.currentTarget.getAttribute("data-index"));setOpen(event)},createHandleMouseLeave=otherHandlers=>event=>{var _otherHandlers$onMous3;null==(_otherHandlers$onMous3=otherHandlers.onMouseLeave)?void 0:_otherHandlers$onMous3.call(otherHandlers,event);setOpen(-1)};return{active,axis,axisProps,dragging,focusedThumbIndex,getHiddenInputProps:(otherHandlers={})=>{var _parameters$step;const ownEventHandlers={onChange:createHandleHiddenInputChange(otherHandlers||
{}),onFocus:createHandleHiddenInputFocus(otherHandlers||{}),onBlur:createHandleHiddenInputBlur(otherHandlers||{})};otherHandlers=(0,_extends2.default)({},otherHandlers,ownEventHandlers);return(0,_extends2.default)({tabIndex,"aria-labelledby":ariaLabelledby,"aria-orientation":orientation,"aria-valuemax":scale(max),"aria-valuemin":scale(min),name,type:"range",min:parameters.min,max:parameters.max,step:null!=(_parameters$step=parameters.step)?_parameters$step:void 0,disabled},otherHandlers,{style:(0,_extends2.default)({},
_utils.visuallyHidden,{direction:isRtl?"rtl":"ltr",width:"100%",height:"100%"})})},getRootProps:(otherHandlers={})=>{const ownEventHandlers={onMouseDown:createHandleMouseDown(otherHandlers||{})};otherHandlers=(0,_extends2.default)({},otherHandlers,ownEventHandlers);return(0,_extends2.default)({ref:handleRef},otherHandlers)},getThumbProps:(otherHandlers={})=>{const ownEventHandlers={onMouseOver:createHandleMouseOver(otherHandlers||{}),onMouseLeave:createHandleMouseLeave(otherHandlers||{})};return(0,_extends2.default)({},
otherHandlers,ownEventHandlers)},marks,open,range,trackLeap,trackOffset:handleFocusRef,values}};exports.valueToPercent=valueToPercent;var _extends2=global(require("module$node_modules$$babel$runtime$helpers$extends")),React=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=
Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$react$index")),_utils=require("module$node_modules$$mui$utils$index");const axisProps={horizontal:{offset:percent=>
({left:`${percent}%`}),leap:percent=>({width:`${percent}%`})},"horizontal-reverse":{offset:percent=>({right:`${percent}%`}),leap:percent=>({width:`${percent}%`})},vertical:{offset:percent=>({bottom:`${percent}%`}),leap:percent=>({height:`${percent}%`})}},Identity=x=>x;exports.Identity=Identity;let cachedSupportsTouchActionNone}
//# sourceMappingURL=module$node_modules$$mui$base$node$SliderUnstyled$useSlider.js.map
