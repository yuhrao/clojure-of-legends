{"version":3,"sources":["promesa/util.cljc"],"mappings":";AAmDA,iCAAA,jCAAMA,0EACHC,MAAMC;AADT,AAEE,IAAMC,WAAQ,6CAAA,7CAACC,+EACK,AAACC,4CAAI,WAAKC;AAAL,AAAa,OAAkBA;IACpC,AAA4BL;AAFhD,AAGE,OAACM,0BAAUJ,SAAQD;;AAEvB,2BAAA,3BAAMM,8DACHC;AADH,AAEE,GAAI,AAACC,uBAAOD;AACV,OAACE,gBAAMF;;AACPA;;;AAEJ,qBAAA,rBAAMG;AAAN,AASK,AAAA,GAAA,QAAAC,oCAAAC,yCAAAC;AAAA;AAAA,AAAA,AAAA;;;;;;;;;;;;AAAA,AAAA,CAAA,AAAA,AAAAC,oFAAA,WAAAC,OAAAC;;AAAA,AAAA,IAAAD,aAAA;AAAA,AAAA,YAAAD,iCAAAE;;;AAAA,CAAA,AAAA,AAAAF,2EAAA,WAAAC;;AAAA,AAAA,IAAAA,aAAA;AAAA,AAAAC;;;AAAA,CAAA,AAAA,AAAAF,sEAAAG;;AAAA,CAAA,AAAA,AAAAH,yFAAA,WAEWS;;AAFX,AAAA,YAAA,RAEWA;AAFX,AAAA;;;AAAA,CAAA,AAAA,AAAAT,2FAAA,WAGaS;;AAHb,AAAA,YAAA,RAGaA;AAHb,AAAA;;;AAAA,CAAA,AAAAT,4CAAA;AAAA,AAAA,AAAA;;;AAAA,CAAA,AAAAA,kDAAA;;AAAA,CAAA,AAAAA,qDAAA;;AAAA,CAAA,AAAAA,0DAAA,WAAAI,mBAAAC,qBAAAC;AAAA,AAAA,OAAAC,iBAAAF,qBAAA;;;AAAA;;;AAAAG,wCAAA,wDAAAN;AAAA,AAAA,YAAAF,iCAAAE;;;AAAAF;;AAAA,YAAAA,iCAAA","names":["promesa.util/has-method?","klass","name","methods","cljs.core.into","cljs.core.map","method","cljs.core/contains?","promesa.util/maybe-deref","o","cljs.core/delay?","cljs.core/deref","promesa.util/mutex","js/promesa","js/promesa.util","js/promesa.util.t_promesa$util36340","promesa.util/t_promesa$util36340","_36342","meta36341","cljs.core/PROTOCOL_SENTINEL","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","promesa.util/->t_promesa$util36340","_"],"sourcesContent":[";; This Source Code Form is subject to the terms of the Mozilla Public\n;; License, v. 2.0. If a copy of the MPL was not distributed with this\n;; file, You can obtain one at http://mozilla.org/MPL/2.0/.\n;;\n;; Copyright (c) Andrey Antukh <niwi@niwi.nz>\n\n(ns ^:no-doc promesa.util\n  (:require [promesa.protocols :as pt])\n  #?(:clj\n     (:import\n      java.lang.reflect.Method\n      java.time.Duration\n      java.util.concurrent.CountDownLatch\n      java.util.concurrent.locks.ReentrantLock\n      java.util.function.BiConsumer\n      java.util.function.BiFunction\n      java.util.function.Consumer\n      java.util.function.Function\n      java.util.function.Supplier)))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n\n#?(:clj\n   (extend-protocol clojure.core/Inst\n     Duration\n     (inst-ms* [v] (.toMillis ^Duration v))))\n\n#?(:clj\n   (deftype SupplierWrapper [f]\n     Supplier\n     (get [_] (f))))\n\n#?(:clj\n   (deftype FunctionWrapper [f]\n     Function\n     (apply [_ v]\n       (f v))))\n\n#?(:clj\n   (deftype BiFunctionWrapper [f]\n     BiFunction\n     (apply [_ a b]\n       (f a b))))\n\n#?(:clj\n   (deftype BiConsumerWrapper [f]\n     BiConsumer\n     (accept [_ a b]\n       (f a b))))\n\n(defn has-method?\n  [klass name]\n  (let [methods (into #{}\n                      (map (fn [method] (.getName ^Method method)))\n                      (.getDeclaredMethods ^Class klass))]\n    (contains? methods name)))\n\n(defn maybe-deref\n  [o]\n  (if (delay? o)\n    (deref o)\n    o))\n\n(defn mutex\n  []\n  #?(:clj\n     (let [m (ReentrantLock.)]\n       (reify\n         pt/ILock\n         (-lock! [_] (.lock m))\n         (-unlock! [_] (.unlock m))))\n     :cljs\n     (reify\n       pt/ILock\n       (-lock! [_])\n       (-unlock! [_]))))\n\n#?(:clj\n(defn count-down-latch\n  [n]\n  (let [cdown (CountDownLatch. (int n))]\n    (reify\n      pt/IAwaitable\n      (-await [_] (pt/-await cdown))\n      (-await [_ d] (pt/-await cdown d))\n\n      clojure.lang.IFn\n      (invoke [_]\n        (.countDown ^CountDownLatch cdown))\n      (invoke [_ _]\n        (.countDown ^CountDownLatch cdown))\n      (invoke [_ _ _]\n        (.countDown ^CountDownLatch cdown))))))\n\n#?(:clj\n(defn wait-all!\n  [promises]\n  (let [total (count promises)]\n    (when (pos? total)\n      (let [cdown-fn (count-down-latch total)]\n        (doseq [p promises]\n          (pt/-finally p cdown-fn))\n        (pt/-await cdown-fn))))))\n"]}