shadow$provide.module$node_modules$buffer$index=function(global,require,module,exports){function createBuffer(length){if(2147483647<length)throw new RangeError('The value "'+length+'" is invalid for option "size"');length=new Uint8Array(length);Object.setPrototypeOf(length,Buffer.prototype);return length}function Buffer(arg,encodingOrOffset,length){if("number"===typeof arg){if("string"===typeof encodingOrOffset)throw new TypeError('The "string" argument must be of type string. Received type number');
return allocUnsafe(arg)}return from(arg,encodingOrOffset,length)}function from(value,encodingOrOffset,length){if("string"===typeof value){var encoding=encodingOrOffset;if("string"!==typeof encoding||""===encoding)encoding="utf8";if(!Buffer.isEncoding(encoding))throw new TypeError("Unknown encoding: "+encoding);encodingOrOffset=byteLength$jscomp$0(value,encoding)|0;length=createBuffer(encodingOrOffset);value=length.write(value,encoding);value!==encodingOrOffset&&(length=length.slice(0,value));return length}if(ArrayBuffer.isView(value))return isInstance(value,
Uint8Array)?(value=new Uint8Array(value),value=fromArrayBuffer(value.buffer,value.byteOffset,value.byteLength)):value=fromArrayLike(value),value;if(null==value)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof value);if(isInstance(value,ArrayBuffer)||value&&isInstance(value.buffer,ArrayBuffer)||"undefined"!==typeof SharedArrayBuffer&&(isInstance(value,SharedArrayBuffer)||value&&isInstance(value.buffer,SharedArrayBuffer)))return fromArrayBuffer(value,
encodingOrOffset,length);if("number"===typeof value)throw new TypeError('The "value" argument must not be of type number. Received type number');encoding=value.valueOf&&value.valueOf();if(null!=encoding&&encoding!==value)return Buffer.from(encoding,encodingOrOffset,length);if(encoding=fromObject(value))return encoding;if("undefined"!==typeof Symbol&&null!=Symbol.toPrimitive&&"function"===typeof value[Symbol.toPrimitive])return Buffer.from(value[Symbol.toPrimitive]("string"),encodingOrOffset,length);
throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof value);}function assertSize(size){if("number"!==typeof size)throw new TypeError('"size" argument must be of type number');if(0>size)throw new RangeError('The value "'+size+'" is invalid for option "size"');}function allocUnsafe(size){assertSize(size);return createBuffer(0>size?0:checked(size)|0)}function fromArrayLike(array){const length=0>array.length?0:checked(array.length)|
0,buf=createBuffer(length);for(let i=0;i<length;i+=1)buf[i]=array[i]&255;return buf}function fromArrayBuffer(array,byteOffset,length){if(0>byteOffset||array.byteLength<byteOffset)throw new RangeError('"offset" is outside of buffer bounds');if(array.byteLength<byteOffset+(length||0))throw new RangeError('"length" is outside of buffer bounds');array=void 0===byteOffset&&void 0===length?new Uint8Array(array):void 0===length?new Uint8Array(array,byteOffset):new Uint8Array(array,byteOffset,length);Object.setPrototypeOf(array,
Buffer.prototype);return array}function fromObject(obj){if(Buffer.isBuffer(obj)){var len=checked(obj.length)|0;const buf=createBuffer(len);if(0===buf.length)return buf;obj.copy(buf,0,0,len);return buf}if(void 0!==obj.length)return(len="number"!==typeof obj.length)||(len=obj.length,len=len!==len),len?createBuffer(0):fromArrayLike(obj);if("Buffer"===obj.type&&Array.isArray(obj.data))return fromArrayLike(obj.data)}function checked(length){if(2147483647<=length)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+
(2147483647).toString(16)+" bytes");return length|0}function byteLength$jscomp$0(string,encoding){if(Buffer.isBuffer(string))return string.length;if(ArrayBuffer.isView(string)||isInstance(string,ArrayBuffer))return string.byteLength;if("string"!==typeof string)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof string);const len=string.length,mustMatch=2<arguments.length&&!0===arguments[2];if(!mustMatch&&0===len)return 0;let loweredCase=
!1;for(;;)switch(encoding){case "ascii":case "latin1":case "binary":return len;case "utf8":case "utf-8":return utf8ToBytes(string).length;case "ucs2":case "ucs-2":case "utf16le":case "utf-16le":return 2*len;case "hex":return len>>>1;case "base64":return base64ToBytes(string).length;default:if(loweredCase)return mustMatch?-1:utf8ToBytes(string).length;encoding=(""+encoding).toLowerCase();loweredCase=!0}}function slowToString(encoding,start,end){let loweredCase=!1;if(void 0===start||0>start)start=0;
if(start>this.length)return"";if(void 0===end||end>this.length)end=this.length;if(0>=end)return"";end>>>=0;start>>>=0;if(end<=start)return"";for(encoding||(encoding="utf8");;)switch(encoding){case "hex":encoding=start;start=this.length;if(!encoding||0>encoding)encoding=0;if(!end||0>end||end>start)end=start;for(start="";encoding<end;++encoding)start+=hexSliceLookupTable[this[encoding]];return start;case "utf8":case "utf-8":return utf8Slice(this,start,end);case "ascii":encoding=start;start="";for(end=
Math.min(this.length,end);encoding<end;++encoding)start+=String.fromCharCode(this[encoding]&127);return start;case "latin1":case "binary":encoding=start;start="";for(end=Math.min(this.length,end);encoding<end;++encoding)start+=String.fromCharCode(this[encoding]);return start;case "base64":return encoding=start,end=0===encoding&&end===this.length?base64.fromByteArray(this):base64.fromByteArray(this.slice(encoding,end)),end;case "ucs2":case "ucs-2":case "utf16le":case "utf-16le":end=this.slice(start,
end);encoding="";for(start=0;start<end.length-1;start+=2)encoding+=String.fromCharCode(end[start]+256*end[start+1]);return encoding;default:if(loweredCase)throw new TypeError("Unknown encoding: "+encoding);encoding=(encoding+"").toLowerCase();loweredCase=!0}}function swap(b,n,m){const i=b[n];b[n]=b[m];b[m]=i}function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){if(0===buffer.length)return-1;"string"===typeof byteOffset?(encoding=byteOffset,byteOffset=0):2147483647<byteOffset?byteOffset=
2147483647:-2147483648>byteOffset&&(byteOffset=-2147483648);byteOffset=+byteOffset;byteOffset!==byteOffset&&(byteOffset=dir?0:buffer.length-1);0>byteOffset&&(byteOffset=buffer.length+byteOffset);if(byteOffset>=buffer.length){if(dir)return-1;byteOffset=buffer.length-1}else if(0>byteOffset)if(dir)byteOffset=0;else return-1;"string"===typeof val&&(val=Buffer.from(val,encoding));if(Buffer.isBuffer(val))return 0===val.length?-1:arrayIndexOf(buffer,val,byteOffset,encoding,dir);if("number"===typeof val)return val&=
255,"function"===typeof Uint8Array.prototype.indexOf?dir?Uint8Array.prototype.indexOf.call(buffer,val,byteOffset):Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset):arrayIndexOf(buffer,[val],byteOffset,encoding,dir);throw new TypeError("val must be string, number or Buffer");}function arrayIndexOf(arr,val,byteOffset,encoding,dir){function read(buf,i){return 1===indexSize?buf[i]:buf.readUInt16BE(i*indexSize)}let indexSize=1;var arrLength=arr.length;let valLength=val.length;if(void 0!==encoding&&
(encoding=String(encoding).toLowerCase(),"ucs2"===encoding||"ucs-2"===encoding||"utf16le"===encoding||"utf-16le"===encoding)){if(2>arr.length||2>val.length)return-1;indexSize=2;arrLength/=2;valLength/=2;byteOffset/=2}if(dir)for(encoding=-1;byteOffset<arrLength;byteOffset++)if(read(arr,byteOffset)===read(val,-1===encoding?0:byteOffset-encoding)){if(-1===encoding&&(encoding=byteOffset),byteOffset-encoding+1===valLength)return encoding*indexSize}else-1!==encoding&&(byteOffset-=byteOffset-encoding),encoding=
-1;else for(byteOffset+valLength>arrLength&&(byteOffset=arrLength-valLength);0<=byteOffset;byteOffset--){arrLength=!0;for(encoding=0;encoding<valLength;encoding++)if(read(arr,byteOffset+encoding)!==read(val,encoding)){arrLength=!1;break}if(arrLength)return byteOffset}return-1}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);for(var res=[];start<end;){var firstByte=buf[start];let codePoint=null,bytesPerSequence=239<firstByte?4:223<firstByte?3:191<firstByte?2:1;if(start+bytesPerSequence<=
end){let secondByte,thirdByte,fourthByte;switch(bytesPerSequence){case 1:128>firstByte&&(codePoint=firstByte);break;case 2:secondByte=buf[start+1];128===(secondByte&192)&&(firstByte=(firstByte&31)<<6|secondByte&63,127<firstByte&&(codePoint=firstByte));break;case 3:secondByte=buf[start+1];thirdByte=buf[start+2];128===(secondByte&192)&&128===(thirdByte&192)&&(firstByte=(firstByte&15)<<12|(secondByte&63)<<6|thirdByte&63,2047<firstByte&&(55296>firstByte||57343<firstByte)&&(codePoint=firstByte));break;
case 4:secondByte=buf[start+1],thirdByte=buf[start+2],fourthByte=buf[start+3],128===(secondByte&192)&&128===(thirdByte&192)&&128===(fourthByte&192)&&(firstByte=(firstByte&15)<<18|(secondByte&63)<<12|(thirdByte&63)<<6|fourthByte&63,65535<firstByte&&1114112>firstByte&&(codePoint=firstByte))}}null===codePoint?(codePoint=65533,bytesPerSequence=1):65535<codePoint&&(codePoint-=65536,res.push(codePoint>>>10&1023|55296),codePoint=56320|codePoint&1023);res.push(codePoint);start+=bytesPerSequence}start=res.length;
if(4096>=start)res=String.fromCharCode.apply(String,res);else{buf="";for(end=0;end<start;)buf+=String.fromCharCode.apply(String,res.slice(end,end+=4096));res=buf}return res}function checkOffset(offset,ext,length){if(0!==offset%1||0>offset)throw new RangeError("offset is not uint");if(offset+ext>length)throw new RangeError("Trying to access beyond buffer length");}function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');
if(value>max||value<min)throw new RangeError('"value" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError("Index out of range");}function wrtBigUInt64LE(buf,value,offset,min,max){checkIntBI(value,min,max,buf,offset,7);min=Number(value&BigInt(4294967295));buf[offset++]=min;min>>=8;buf[offset++]=min;min>>=8;buf[offset++]=min;buf[offset++]=min>>8;value=Number(value>>BigInt(32)&BigInt(4294967295));buf[offset++]=value;value>>=8;buf[offset++]=value;value>>=8;buf[offset++]=value;buf[offset++]=
value>>8;return offset}function wrtBigUInt64BE(buf,value,offset,min,max){checkIntBI(value,min,max,buf,offset,7);min=Number(value&BigInt(4294967295));buf[offset+7]=min;min>>=8;buf[offset+6]=min;min>>=8;buf[offset+5]=min;buf[offset+4]=min>>8;value=Number(value>>BigInt(32)&BigInt(4294967295));buf[offset+3]=value;value>>=8;buf[offset+2]=value;value>>=8;buf[offset+1]=value;buf[offset]=value>>8;return offset+8}function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError("Index out of range");
if(0>offset)throw new RangeError("Index out of range");}function writeFloat(buf,value,offset,littleEndian,noAssert){value=+value;offset>>>=0;noAssert||checkIEEE754(buf,value,offset,4,3.4028234663852886E38,-3.4028234663852886E38);ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4}function writeDouble(buf,value,offset,littleEndian,noAssert){value=+value;offset>>>=0;noAssert||checkIEEE754(buf,value,offset,8,1.7976931348623157E308,-1.7976931348623157E308);ieee754.write(buf,value,offset,
littleEndian,52,8);return offset+8}function E(sym,getMessage,Base){errors[sym]=class extends Base{constructor(){super();Object.defineProperty(this,"message",{value:getMessage.apply(this,arguments),writable:!0,configurable:!0});this.name=`${this.name} [${sym}]`;this.stack;delete this.name}get code(){return sym}set code(value){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value,writable:!0})}toString(){return`${this.name} [${sym}]: ${this.message}`}}}function addNumericalSeparator(val){let res=
"",i=val.length;const start="-"===val[0]?1:0;for(;i>=start+4;i-=3)res=`_${val.slice(i-3,i)}${res}`;return`${val.slice(0,i)}${res}`}function checkIntBI(value,min,max,buf,offset,byteLength){if(value>max||value<min)throw buf="bigint"===typeof min?"n":"",new errors.ERR_OUT_OF_RANGE("value",3<byteLength?0===min||min===BigInt(0)?`>= 0${buf} and < 2${buf} ** ${8*(byteLength+1)}${buf}`:`>= -(2${buf} ** ${8*(byteLength+1)-1}${buf}) and < 2 ** `+`${8*(byteLength+1)-1}${buf}`:`>= ${min}${buf} and <= ${max}${buf}`,
value);validateNumber(offset,"offset");void 0!==buf[offset]&&void 0!==buf[offset+byteLength]||boundsError(offset,buf.length-(byteLength+1))}function validateNumber(value,name){if("number"!==typeof value)throw new errors.ERR_INVALID_ARG_TYPE(name,"number",value);}function boundsError(value,length,type){if(Math.floor(value)!==value)throw validateNumber(value,type),new errors.ERR_OUT_OF_RANGE(type||"offset","an integer",value);if(0>length)throw new errors.ERR_BUFFER_OUT_OF_BOUNDS;throw new errors.ERR_OUT_OF_RANGE(type||
"offset",`>= ${type?1:0} and <= ${length}`,value);}function utf8ToBytes(string,units){units=units||Infinity;let codePoint;const length=string.length;let leadSurrogate=null;const bytes=[];for(let i=0;i<length;++i){codePoint=string.charCodeAt(i);if(55295<codePoint&&57344>codePoint){if(!leadSurrogate){if(56319<codePoint){-1<(units-=3)&&bytes.push(239,191,189);continue}else if(i+1===length){-1<(units-=3)&&bytes.push(239,191,189);continue}leadSurrogate=codePoint;continue}if(56320>codePoint){-1<(units-=
3)&&bytes.push(239,191,189);leadSurrogate=codePoint;continue}codePoint=(leadSurrogate-55296<<10|codePoint-56320)+65536}else leadSurrogate&&-1<(units-=3)&&bytes.push(239,191,189);leadSurrogate=null;if(128>codePoint){if(0>--units)break;bytes.push(codePoint)}else if(2048>codePoint){if(0>(units-=2))break;bytes.push(codePoint>>6|192,codePoint&63|128)}else if(65536>codePoint){if(0>(units-=3))break;bytes.push(codePoint>>12|224,codePoint>>6&63|128,codePoint&63|128)}else if(1114112>codePoint){if(0>(units-=
4))break;bytes.push(codePoint>>18|240,codePoint>>12&63|128,codePoint>>6&63|128,codePoint&63|128)}else throw Error("Invalid code point");}return bytes}function base64ToBytes(str){var JSCompiler_temp_const=base64,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.toByteArray;str=str.split("\x3d")[0];str=str.trim().replace(INVALID_BASE64_RE,"");if(2>str.length)str="";else for(;0!==str.length%4;)str+="\x3d";return JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,str)}function blitBuffer(src,
dst,offset,length){let i;for(i=0;i<length&&!(i+offset>=dst.length||i>=src.length);++i)dst[i+offset]=src[i];return i}function isInstance(obj,type){return obj instanceof type||null!=obj&&null!=obj.constructor&&null!=obj.constructor.name&&obj.constructor.name===type.name}function defineBigIntMethod(fn){return"undefined"===typeof BigInt?BufferBigIntNotDefined:fn}function BufferBigIntNotDefined(){throw Error("BigInt not supported");}const base64=require("module$node_modules$base64_js$index"),ieee754=require("module$node_modules$ieee754$index");
global="function"===typeof Symbol&&"function"===typeof Symbol["for"]?Symbol["for"]("nodejs.util.inspect.custom"):null;exports.Buffer=Buffer;exports.SlowBuffer=function(length){+length!=length&&(length=0);return Buffer.alloc(+length)};exports.INSPECT_MAX_BYTES=50;exports.kMaxLength=2147483647;Buffer.TYPED_ARRAY_SUPPORT=function(){try{const arr=new Uint8Array(1),proto={foo:function(){return 42}};Object.setPrototypeOf(proto,Uint8Array.prototype);Object.setPrototypeOf(arr,proto);return 42===arr.foo()}catch(e){return!1}}();
Buffer.TYPED_ARRAY_SUPPORT||"undefined"===typeof console||"function"!==typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");Object.defineProperty(Buffer.prototype,"parent",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.buffer}});Object.defineProperty(Buffer.prototype,"offset",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.byteOffset}});
Buffer.poolSize=8192;Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);Buffer.alloc=function(size,fill,encoding){assertSize(size);size=0>=size?createBuffer(size):void 0!==fill?"string"===typeof encoding?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill):createBuffer(size);return size};Buffer.allocUnsafe=function(size){return allocUnsafe(size)};
Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size)};Buffer.isBuffer=function(b){return null!=b&&!0===b._isBuffer&&b!==Buffer.prototype};Buffer.compare=function(a,b){isInstance(a,Uint8Array)&&(a=Buffer.from(a,a.offset,a.byteLength));isInstance(b,Uint8Array)&&(b=Buffer.from(b,b.offset,b.byteLength));if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(a===b)return 0;let x=a.length,y=b.length;for(let i=
0,len=Math.min(x,y);i<len;++i)if(a[i]!==b[i]){x=a[i];y=b[i];break}return x<y?-1:y<x?1:0};Buffer.isEncoding=function(encoding){switch(String(encoding).toLowerCase()){case "hex":case "utf8":case "utf-8":case "ascii":case "latin1":case "binary":case "base64":case "ucs2":case "ucs-2":case "utf16le":case "utf-16le":return!0;default:return!1}};Buffer.concat=function(list,length){if(!Array.isArray(list))throw new TypeError('"list" argument must be an Array of Buffers');if(0===list.length)return Buffer.alloc(0);
let i;if(void 0===length)for(i=length=0;i<list.length;++i)length+=list[i].length;length=Buffer.allocUnsafe(length);let pos=0;for(i=0;i<list.length;++i){let buf=list[i];if(isInstance(buf,Uint8Array))pos+buf.length>length.length?(Buffer.isBuffer(buf)||(buf=Buffer.from(buf)),buf.copy(length,pos)):Uint8Array.prototype.set.call(length,buf,pos);else if(Buffer.isBuffer(buf))buf.copy(length,pos);else throw new TypeError('"list" argument must be an Array of Buffers');pos+=buf.length}return length};Buffer.byteLength=
byteLength$jscomp$0;Buffer.prototype._isBuffer=!0;Buffer.prototype.swap16=function(){const len=this.length;if(0!==len%2)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let i=0;i<len;i+=2)swap(this,i,i+1);return this};Buffer.prototype.swap32=function(){const len=this.length;if(0!==len%4)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let i=0;i<len;i+=4)swap(this,i,i+3),swap(this,i+1,i+2);return this};Buffer.prototype.swap64=function(){const len=this.length;
if(0!==len%8)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let i=0;i<len;i+=8)swap(this,i,i+7),swap(this,i+1,i+6),swap(this,i+2,i+5),swap(this,i+3,i+4);return this};Buffer.prototype.toString=function(){const length=this.length;return 0===length?"":0===arguments.length?utf8Slice(this,0,length):slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function(b){if(!Buffer.isBuffer(b))throw new TypeError("Argument must be a Buffer");
return this===b?!0:0===Buffer.compare(this,b)};Buffer.prototype.inspect=function(){let str;const max=exports.INSPECT_MAX_BYTES;str=this.toString("hex",0,max).replace(/(.{2})/g,"$1 ").trim();this.length>max&&(str+=" ... ");return"\x3cBuffer "+str+"\x3e"};global&&(Buffer.prototype[global]=Buffer.prototype.inspect);Buffer.prototype.compare=function(target,start,end,thisStart,thisEnd){isInstance(target,Uint8Array)&&(target=Buffer.from(target,target.offset,target.byteLength));if(!Buffer.isBuffer(target))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+
typeof target);void 0===start&&(start=0);void 0===end&&(end=target?target.length:0);void 0===thisStart&&(thisStart=0);void 0===thisEnd&&(thisEnd=this.length);if(0>start||end>target.length||0>thisStart||thisEnd>this.length)throw new RangeError("out of range index");if(thisStart>=thisEnd&&start>=end)return 0;if(thisStart>=thisEnd)return-1;if(start>=end)return 1;start>>>=0;end>>>=0;thisStart>>>=0;thisEnd>>>=0;if(this===target)return 0;let x=thisEnd-thisStart,y=end-start;const len=Math.min(x,y);thisStart=
this.slice(thisStart,thisEnd);target=target.slice(start,end);for(start=0;start<len;++start)if(thisStart[start]!==target[start]){x=thisStart[start];y=target[start];break}return x<y?-1:y<x?1:0};Buffer.prototype.includes=function(val,byteOffset,encoding){return-1!==this.indexOf(val,byteOffset,encoding)};Buffer.prototype.indexOf=function(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,!0)};Buffer.prototype.lastIndexOf=function(val,byteOffset,encoding){return bidirectionalIndexOf(this,
val,byteOffset,encoding,!1)};Buffer.prototype.write=function(string,offset,length,encoding){if(void 0===offset)encoding="utf8",length=this.length,offset=0;else if(void 0===length&&"string"===typeof offset)encoding=offset,length=this.length,offset=0;else if(isFinite(offset))offset>>>=0,isFinite(length)?(length>>>=0,void 0===encoding&&(encoding="utf8")):(encoding=length,length=void 0);else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");var remaining=this.length-
offset;if(void 0===length||length>remaining)length=remaining;if(0<string.length&&(0>length||0>offset)||offset>this.length)throw new RangeError("Attempt to write outside buffer bounds");encoding||(encoding="utf8");for(remaining=!1;;)switch(encoding){case "hex":a:{offset=Number(offset)||0;encoding=this.length-offset;length?(length=Number(length),length>encoding&&(length=encoding)):length=encoding;encoding=string.length;length>encoding/2&&(length=encoding/2);for(encoding=0;encoding<length;++encoding){remaining=
parseInt(string.substr(2*encoding,2),16);if(remaining!==remaining){string=encoding;break a}this[offset+encoding]=remaining}string=encoding}return string;case "utf8":case "utf-8":return blitBuffer(utf8ToBytes(string,this.length-offset),this,offset,length);case "ascii":case "latin1":case "binary":encoding=[];for(remaining=0;remaining<string.length;++remaining)encoding.push(string.charCodeAt(remaining)&255);return blitBuffer(encoding,this,offset,length);case "base64":return blitBuffer(base64ToBytes(string),
this,offset,length);case "ucs2":case "ucs-2":case "utf16le":case "utf-16le":var lo=void 0;encoding=this.length-offset;const byteArray=[];for(let i=0;i<string.length&&!(0>(encoding-=2));++i)lo=string.charCodeAt(i),remaining=lo>>8,lo%=256,byteArray.push(lo),byteArray.push(remaining);return blitBuffer(byteArray,this,offset,length);default:if(remaining)throw new TypeError("Unknown encoding: "+encoding);encoding=(""+encoding).toLowerCase();remaining=!0}};Buffer.prototype.toJSON=function(){return{type:"Buffer",
data:Array.prototype.slice.call(this._arr||this,0)}};Buffer.prototype.slice=function(start,end){const len=this.length;start=~~start;end=void 0===end?len:~~end;0>start?(start+=len,0>start&&(start=0)):start>len&&(start=len);0>end?(end+=len,0>end&&(end=0)):end>len&&(end=len);end<start&&(end=start);start=this.subarray(start,end);Object.setPrototypeOf(start,Buffer.prototype);return start};Buffer.prototype.readUintLE=Buffer.prototype.readUIntLE=function(offset,byteLength,noAssert){offset>>>=0;byteLength>>>=
0;noAssert||checkOffset(offset,byteLength,this.length);noAssert=this[offset];let mul=1,i=0;for(;++i<byteLength&&(mul*=256);)noAssert+=this[offset+i]*mul;return noAssert};Buffer.prototype.readUintBE=Buffer.prototype.readUIntBE=function(offset,byteLength,noAssert){offset>>>=0;byteLength>>>=0;noAssert||checkOffset(offset,byteLength,this.length);noAssert=this[offset+--byteLength];let mul=1;for(;0<byteLength&&(mul*=256);)noAssert+=this[offset+--byteLength]*mul;return noAssert};Buffer.prototype.readUint8=
Buffer.prototype.readUInt8=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,1,this.length);return this[offset]};Buffer.prototype.readUint16LE=Buffer.prototype.readUInt16LE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,2,this.length);return this[offset]|this[offset+1]<<8};Buffer.prototype.readUint16BE=Buffer.prototype.readUInt16BE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,2,this.length);return this[offset]<<8|this[offset+1]};Buffer.prototype.readUint32LE=
Buffer.prototype.readUInt32LE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,4,this.length);return(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+16777216*this[offset+3]};Buffer.prototype.readUint32BE=Buffer.prototype.readUInt32BE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,4,this.length);return 16777216*this[offset]+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3])};Buffer.prototype.readBigUInt64LE=defineBigIntMethod(function(offset){offset>>>=0;
validateNumber(offset,"offset");var first=this[offset];const last=this[offset+7];void 0!==first&&void 0!==last||boundsError(offset,this.length-8);first=first+256*this[++offset]+65536*this[++offset]+this[++offset]*2**24;offset=this[++offset]+256*this[++offset]+65536*this[++offset]+last*2**24;return BigInt(first)+(BigInt(offset)<<BigInt(32))});Buffer.prototype.readBigUInt64BE=defineBigIntMethod(function(offset){offset>>>=0;validateNumber(offset,"offset");var first=this[offset];const last=this[offset+
7];void 0!==first&&void 0!==last||boundsError(offset,this.length-8);first=first*2**24+65536*this[++offset]+256*this[++offset]+this[++offset];offset=this[++offset]*2**24+65536*this[++offset]+256*this[++offset]+last;return(BigInt(first)<<BigInt(32))+BigInt(offset)});Buffer.prototype.readIntLE=function(offset,byteLength,noAssert){offset>>>=0;byteLength>>>=0;noAssert||checkOffset(offset,byteLength,this.length);noAssert=this[offset];let mul=1,i=0;for(;++i<byteLength&&(mul*=256);)noAssert+=this[offset+
i]*mul;noAssert>=128*mul&&(noAssert-=Math.pow(2,8*byteLength));return noAssert};Buffer.prototype.readIntBE=function(offset,byteLength,noAssert){offset>>>=0;byteLength>>>=0;noAssert||checkOffset(offset,byteLength,this.length);noAssert=byteLength;let mul=1,val=this[offset+--noAssert];for(;0<noAssert&&(mul*=256);)val+=this[offset+--noAssert]*mul;val>=128*mul&&(val-=Math.pow(2,8*byteLength));return val};Buffer.prototype.readInt8=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,1,this.length);
return this[offset]&128?-1*(255-this[offset]+1):this[offset]};Buffer.prototype.readInt16LE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,2,this.length);offset=this[offset]|this[offset+1]<<8;return offset&32768?offset|4294901760:offset};Buffer.prototype.readInt16BE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,2,this.length);offset=this[offset+1]|this[offset]<<8;return offset&32768?offset|4294901760:offset};Buffer.prototype.readInt32LE=function(offset,noAssert){offset>>>=
0;noAssert||checkOffset(offset,4,this.length);return this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24};Buffer.prototype.readInt32BE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,4,this.length);return this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3]};Buffer.prototype.readBigInt64LE=defineBigIntMethod(function(offset){offset>>>=0;validateNumber(offset,"offset");const first=this[offset],last=this[offset+7];void 0!==first&&void 0!==last||boundsError(offset,
this.length-8);return(BigInt(this[offset+4]+256*this[offset+5]+65536*this[offset+6]+(last<<24))<<BigInt(32))+BigInt(first+256*this[++offset]+65536*this[++offset]+this[++offset]*2**24)});Buffer.prototype.readBigInt64BE=defineBigIntMethod(function(offset){offset>>>=0;validateNumber(offset,"offset");var first=this[offset];const last=this[offset+7];void 0!==first&&void 0!==last||boundsError(offset,this.length-8);first=(first<<24)+65536*this[++offset]+256*this[++offset]+this[++offset];return(BigInt(first)<<
BigInt(32))+BigInt(this[++offset]*2**24+65536*this[++offset]+256*this[++offset]+last)});Buffer.prototype.readFloatLE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,4,this.length);return ieee754.read(this,offset,!0,23,4)};Buffer.prototype.readFloatBE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,4,this.length);return ieee754.read(this,offset,!1,23,4)};Buffer.prototype.readDoubleLE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,8,this.length);
return ieee754.read(this,offset,!0,52,8)};Buffer.prototype.readDoubleBE=function(offset,noAssert){offset>>>=0;noAssert||checkOffset(offset,8,this.length);return ieee754.read(this,offset,!1,52,8)};Buffer.prototype.writeUintLE=Buffer.prototype.writeUIntLE=function(value,offset,byteLength,noAssert){value=+value;offset>>>=0;byteLength>>>=0;noAssert||checkInt(this,value,offset,byteLength,Math.pow(2,8*byteLength)-1,0);noAssert=1;let i=0;for(this[offset]=value&255;++i<byteLength&&(noAssert*=256);)this[offset+
i]=value/noAssert&255;return offset+byteLength};Buffer.prototype.writeUintBE=Buffer.prototype.writeUIntBE=function(value,offset,byteLength,noAssert){value=+value;offset>>>=0;byteLength>>>=0;noAssert||checkInt(this,value,offset,byteLength,Math.pow(2,8*byteLength)-1,0);noAssert=byteLength-1;let mul=1;for(this[offset+noAssert]=value&255;0<=--noAssert&&(mul*=256);)this[offset+noAssert]=value/mul&255;return offset+byteLength};Buffer.prototype.writeUint8=Buffer.prototype.writeUInt8=function(value,offset,
noAssert){value=+value;offset>>>=0;noAssert||checkInt(this,value,offset,1,255,0);this[offset]=value&255;return offset+1};Buffer.prototype.writeUint16LE=Buffer.prototype.writeUInt16LE=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||checkInt(this,value,offset,2,65535,0);this[offset]=value&255;this[offset+1]=value>>>8;return offset+2};Buffer.prototype.writeUint16BE=Buffer.prototype.writeUInt16BE=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||checkInt(this,value,
offset,2,65535,0);this[offset]=value>>>8;this[offset+1]=value&255;return offset+2};Buffer.prototype.writeUint32LE=Buffer.prototype.writeUInt32LE=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||checkInt(this,value,offset,4,4294967295,0);this[offset+3]=value>>>24;this[offset+2]=value>>>16;this[offset+1]=value>>>8;this[offset]=value&255;return offset+4};Buffer.prototype.writeUint32BE=Buffer.prototype.writeUInt32BE=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||
checkInt(this,value,offset,4,4294967295,0);this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&255;return offset+4};Buffer.prototype.writeBigUInt64LE=defineBigIntMethod(function(value,offset=0){return wrtBigUInt64LE(this,value,offset,BigInt(0),BigInt("0xffffffffffffffff"))});Buffer.prototype.writeBigUInt64BE=defineBigIntMethod(function(value,offset=0){return wrtBigUInt64BE(this,value,offset,BigInt(0),BigInt("0xffffffffffffffff"))});Buffer.prototype.writeIntLE=
function(value,offset,byteLength,noAssert){value=+value;offset>>>=0;noAssert||(noAssert=Math.pow(2,8*byteLength-1),checkInt(this,value,offset,byteLength,noAssert-1,-noAssert));noAssert=0;let mul=1,sub=0;for(this[offset]=value&255;++noAssert<byteLength&&(mul*=256);)0>value&&0===sub&&0!==this[offset+noAssert-1]&&(sub=1),this[offset+noAssert]=(value/mul>>0)-sub&255;return offset+byteLength};Buffer.prototype.writeIntBE=function(value,offset,byteLength,noAssert){value=+value;offset>>>=0;noAssert||(noAssert=
Math.pow(2,8*byteLength-1),checkInt(this,value,offset,byteLength,noAssert-1,-noAssert));noAssert=byteLength-1;let mul=1,sub=0;for(this[offset+noAssert]=value&255;0<=--noAssert&&(mul*=256);)0>value&&0===sub&&0!==this[offset+noAssert+1]&&(sub=1),this[offset+noAssert]=(value/mul>>0)-sub&255;return offset+byteLength};Buffer.prototype.writeInt8=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||checkInt(this,value,offset,1,127,-128);0>value&&(value=255+value+1);this[offset]=value&255;return offset+
1};Buffer.prototype.writeInt16LE=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||checkInt(this,value,offset,2,32767,-32768);this[offset]=value&255;this[offset+1]=value>>>8;return offset+2};Buffer.prototype.writeInt16BE=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||checkInt(this,value,offset,2,32767,-32768);this[offset]=value>>>8;this[offset+1]=value&255;return offset+2};Buffer.prototype.writeInt32LE=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||
checkInt(this,value,offset,4,2147483647,-2147483648);this[offset]=value&255;this[offset+1]=value>>>8;this[offset+2]=value>>>16;this[offset+3]=value>>>24;return offset+4};Buffer.prototype.writeInt32BE=function(value,offset,noAssert){value=+value;offset>>>=0;noAssert||checkInt(this,value,offset,4,2147483647,-2147483648);0>value&&(value=4294967295+value+1);this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&255;return offset+4};Buffer.prototype.writeBigInt64LE=
defineBigIntMethod(function(value,offset=0){return wrtBigUInt64LE(this,value,offset,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});Buffer.prototype.writeBigInt64BE=defineBigIntMethod(function(value,offset=0){return wrtBigUInt64BE(this,value,offset,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});Buffer.prototype.writeFloatLE=function(value,offset,noAssert){return writeFloat(this,value,offset,!0,noAssert)};Buffer.prototype.writeFloatBE=function(value,offset,noAssert){return writeFloat(this,
value,offset,!1,noAssert)};Buffer.prototype.writeDoubleLE=function(value,offset,noAssert){return writeDouble(this,value,offset,!0,noAssert)};Buffer.prototype.writeDoubleBE=function(value,offset,noAssert){return writeDouble(this,value,offset,!1,noAssert)};Buffer.prototype.copy=function(target,targetStart,start,end){if(!Buffer.isBuffer(target))throw new TypeError("argument should be a Buffer");start||(start=0);end||0===end||(end=this.length);targetStart>=target.length&&(targetStart=target.length);targetStart||
(targetStart=0);0<end&&end<start&&(end=start);if(end===start||0===target.length||0===this.length)return 0;if(0>targetStart)throw new RangeError("targetStart out of bounds");if(0>start||start>=this.length)throw new RangeError("Index out of range");if(0>end)throw new RangeError("sourceEnd out of bounds");end>this.length&&(end=this.length);target.length-targetStart<end-start&&(end=target.length-targetStart+start);const len=end-start;this===target&&"function"===typeof Uint8Array.prototype.copyWithin?
this.copyWithin(targetStart,start,end):Uint8Array.prototype.set.call(target,this.subarray(start,end),targetStart);return len};Buffer.prototype.fill=function(val,start,end,encoding){if("string"===typeof val){"string"===typeof start?(encoding=start,start=0,end=this.length):"string"===typeof end&&(encoding=end,end=this.length);if(void 0!==encoding&&"string"!==typeof encoding)throw new TypeError("encoding must be a string");if("string"===typeof encoding&&!Buffer.isEncoding(encoding))throw new TypeError("Unknown encoding: "+
encoding);if(1===val.length){var code=val.charCodeAt(0);if("utf8"===encoding&&128>code||"latin1"===encoding)val=code}}else"number"===typeof val?val&=255:"boolean"===typeof val&&(val=Number(val));if(0>start||this.length<start||this.length<end)throw new RangeError("Out of range index");if(end<=start)return this;start>>>=0;end=void 0===end?this.length:end>>>0;val||(val=0);if("number"===typeof val)for(encoding=start;encoding<end;++encoding)this[encoding]=val;else{code=Buffer.isBuffer(val)?val:Buffer.from(val,
encoding);const len=code.length;if(0===len)throw new TypeError('The value "'+val+'" is invalid for argument "value"');for(encoding=0;encoding<end-start;++encoding)this[encoding+start]=code[encoding%len]}return this};const errors={};E("ERR_BUFFER_OUT_OF_BOUNDS",function(name){return name?`${name} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError);E("ERR_INVALID_ARG_TYPE",function(name,actual){return`The "${name}" argument must be of type number. Received type ${typeof actual}`},
TypeError);E("ERR_OUT_OF_RANGE",function(str,range,input){str=`The value of "${str}" is out of range.`;let received=input;if(Number.isInteger(input)&&Math.abs(input)>2**32)received=addNumericalSeparator(String(input));else if("bigint"===typeof input){received=String(input);if(input>BigInt(2)**BigInt(32)||input<-(BigInt(2)**BigInt(32)))received=addNumericalSeparator(received);received+="n"}return str+` It must be ${range}. Received ${received}`},RangeError);const INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g,
hexSliceLookupTable=function(){const table=Array(256);for(let i=0;16>i;++i){const i16=16*i;for(let j=0;16>j;++j)table[i16+j]="0123456789abcdef"[i]+"0123456789abcdef"[j]}return table}()}
//# sourceMappingURL=module$node_modules$buffer$index.js.map
