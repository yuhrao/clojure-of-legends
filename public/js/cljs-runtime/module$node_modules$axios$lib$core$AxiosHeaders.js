shadow$provide.module$node_modules$axios$lib$core$AxiosHeaders=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function normalizeHeader(header){return header&&String(header).trim().toLowerCase()}function normalizeValue(value){return!1===value||null==value?value:_utils.default.isArray(value)?value.map(normalizeValue):String(value)}function matchHeaderValue(context,value,header,filter){if(_utils.default.isFunction(filter))return filter.call(this,
value,header);if(_utils.default.isString(value)){if(_utils.default.isString(filter))return-1!==value.indexOf(filter);if(_utils.default.isRegExp(filter))return filter.test(value)}}function formatHeader(header){return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(w,char,str)=>char.toUpperCase()+str)}function buildAccessors(obj,header){const accessorName=_utils.default.toCamelCase(" "+header);["get","set","has"].forEach(methodName=>{Object.defineProperty(obj,methodName+accessorName,{value:function(arg1,
arg2,arg3){return this[methodName].call(this,header,arg1,arg2,arg3)},configurable:!0})})}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _utils=_interopRequireDefault(require("module$node_modules$axios$lib$utils")),_parseHeaders=_interopRequireDefault(require("module$node_modules$axios$lib$helpers$parseHeaders"));const $internals=Symbol("internals");class AxiosHeaders{constructor(headers){headers&&this.set(headers)}set(header,valueOrRewrite,rewrite){function setHeader(_value,
_header,_rewrite){var lHeader=normalizeHeader(_header);if(!lHeader)throw Error("header name must be a non-empty string");lHeader=_utils.default.findKey(self,lHeader);if(!lHeader||void 0===self[lHeader]||!0===_rewrite||void 0===_rewrite&&!1!==self[lHeader])self[lHeader||_header]=normalizeValue(_value)}const self=this,setHeaders=(headers,_rewrite)=>_utils.default.forEach(headers,(_value,_header)=>setHeader(_value,_header,_rewrite));_utils.default.isPlainObject(header)||header instanceof this.constructor?
setHeaders(header,valueOrRewrite):_utils.default.isString(header)&&(header=header.trim())&&!/^[-_a-zA-Z]+$/.test(header.trim())?setHeaders((0,_parseHeaders.default)(header),valueOrRewrite):null!=header&&setHeader(valueOrRewrite,header,rewrite);return this}get(header,parser){if(header=normalizeHeader(header))if(header=_utils.default.findKey(this,header)){var value=this[header];if(!parser)return value;if(!0===parser){parser=value;header=Object.create(null);value=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let match;
for(;match=value.exec(parser);)header[match[1]]=match[2];return header}if(_utils.default.isFunction(parser))return parser.call(this,value,header);if(_utils.default.isRegExp(parser))return parser.exec(value);throw new TypeError("parser must be boolean|regexp|function");}}has(header,matcher){return(header=normalizeHeader(header))?(header=_utils.default.findKey(this,header),!(!header||matcher&&!matchHeaderValue(this,this[header],header,matcher))):!1}delete(header,matcher){function deleteHeader(_header){if(_header=
normalizeHeader(_header))!(_header=_utils.default.findKey(self,_header))||matcher&&!matchHeaderValue(self,self[_header],_header,matcher)||(delete self[_header],deleted=!0)}const self=this;let deleted=!1;_utils.default.isArray(header)?header.forEach(deleteHeader):deleteHeader(header);return deleted}clear(){return Object.keys(this).forEach(this.delete.bind(this))}normalize(format){const self=this,headers={};_utils.default.forEach(this,(value,header)=>{var key=_utils.default.findKey(headers,header);
key?(self[key]=normalizeValue(value),delete self[header]):(key=format?formatHeader(header):String(header).trim(),key!==header&&delete self[header],self[key]=normalizeValue(value),headers[key]=!0)});return this}concat(...targets){return this.constructor.concat(this,...targets)}toJSON(asStrings){const obj=Object.create(null);_utils.default.forEach(this,(value,header)=>{null!=value&&!1!==value&&(obj[header]=asStrings&&_utils.default.isArray(value)?value.join(", "):value)});return obj}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([header,
value])=>header+": "+value).join("\n")}get [Symbol.toStringTag](){return"AxiosHeaders"}static from(thing){return thing instanceof this?thing:new this(thing)}static concat(first,...targets){const computed=new this(first);targets.forEach(target=>computed.set(target));return computed}static accessor(header){function defineAccessor(_header){const lHeader=normalizeHeader(_header);accessors[lHeader]||(buildAccessors(prototype,_header),accessors[lHeader]=!0)}const accessors=(this[$internals]=this[$internals]=
{accessors:{}}).accessors,prototype=this.prototype;_utils.default.isArray(header)?header.forEach(defineAccessor):defineAccessor(header);return this}}AxiosHeaders.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent"]);_utils.default.freezeMethods(AxiosHeaders.prototype);_utils.default.freezeMethods(AxiosHeaders);exports.default=AxiosHeaders}
//# sourceMappingURL=module$node_modules$axios$lib$core$AxiosHeaders.js.map
