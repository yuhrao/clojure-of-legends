shadow$provide.module$node_modules$axios$lib$cancel$CancelToken=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _CanceledError=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require("module$node_modules$axios$lib$cancel$CanceledError"));class CancelToken{constructor(executor){if("function"!==typeof executor)throw new TypeError("executor must be a function.");let resolvePromise;this.promise=new Promise(function(resolve){resolvePromise=
resolve});const token=this;this.promise.then(cancel=>{if(token._listeners){for(var i=token._listeners.length;0<i--;)token._listeners[i](cancel);token._listeners=null}});this.promise.then=onfulfilled=>{let _resolve;onfulfilled=(new Promise(resolve=>{token.subscribe(resolve);_resolve=resolve})).then(onfulfilled);onfulfilled.cancel=function(){token.unsubscribe(_resolve)};return onfulfilled};executor(function(message,config,request){token.reason||(token.reason=new _CanceledError.default(message,config,
request),resolvePromise(token.reason))})}throwIfRequested(){if(this.reason)throw this.reason;}subscribe(listener){this.reason?listener(this.reason):this._listeners?this._listeners.push(listener):this._listeners=[listener]}unsubscribe(listener){this._listeners&&(listener=this._listeners.indexOf(listener),-1!==listener&&this._listeners.splice(listener,1))}static source(){let cancel;return{token:new CancelToken(function(c){cancel=c}),cancel}}}exports.default=CancelToken}
//# sourceMappingURL=module$node_modules$axios$lib$cancel$CancelToken.js.map
