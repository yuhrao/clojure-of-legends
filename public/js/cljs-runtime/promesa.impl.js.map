{"version":3,"sources":["promesa/impl.cljc"],"mappings":"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","names":["promesa.impl/*default-promise*","js/Promise","promesa.impl/resolved","v","promesa.impl/rejected","promesa.impl/deferred","state","obj","resolve","reject","x36617","cljs.core/PROTOCOL_SENTINEL","_","promesa.impl/extend-promise!","t","p","it","f","p1__36618#","e","p1__36619#","p1__36620#","p1__36621#","p1__36622#","p1__36623#","p1__36624#","p1__36625#","p1__36626#","p1__36627#","p1__36628#","p1__36629#","executor","p1__36630#","p1__36631#","promesa.protocols/IPromiseFactory","promesa.protocols/-promise","js/Error","promesa.impl/promise->str","writer","opts","cljs.core/-write"],"sourcesContent":[";; This Source Code Form is subject to the terms of the Mozilla Public\n;; License, v. 2.0. If a copy of the MPL was not distributed with this\n;; file, You can obtain one at http://mozilla.org/MPL/2.0/.\n;;\n;; Copyright (c) Andrey Antukh <niwi@niwi.nz>\n\n(ns ^:no-doc promesa.impl\n  \"Implementation of promise protocols.\"\n  (:require [promesa.protocols :as pt]\n            [promesa.util :as pu]\n            [promesa.exec :as exec])\n  #?(:clj\n     (:import\n      java.time.Duration\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionException\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.CountDownLatch\n      java.util.concurrent.ExecutionException\n      java.util.concurrent.Executor\n      java.util.concurrent.TimeUnit\n      java.util.concurrent.TimeoutException\n      java.util.function.Function\n      java.util.function.Supplier)))\n\n;; --- Global Constants\n\n#?(:clj (set! *warn-on-reflection* true))\n#?(:cljs (def ^:dynamic *default-promise* js/Promise))\n\n(defn resolved\n  [v]\n  #?(:cljs (.resolve *default-promise* v)\n     :clj (CompletableFuture/completedFuture v)))\n\n(defn rejected\n  [v]\n  #?(:cljs (.reject *default-promise* v)\n     :clj (let [p (CompletableFuture.)]\n            (.completeExceptionally ^CompletableFuture p v)\n            p)))\n\n#?(:clj\n   (defn unwrap-completion-exception\n     {:no-doc true}\n     [cause]\n     (if (instance? CompletionException cause)\n       (.getCause ^CompletionException cause)\n       cause)))\n\n#?(:clj (def fw-identity (pu/->FunctionWrapper identity)))\n\n#?(:clj\n   (defn unwrap-completion-stage\n     {:no-doc true}\n     [it]\n     (.thenCompose ^CompletionStage it ^Function fw-identity)))\n\n;; --- Promise Impl\n\n(defn deferred\n  []\n  #?(:clj (CompletableFuture.)\n     :cljs\n     (let [state #js {}\n           obj (new *default-promise*\n                    (fn [resolve reject]\n                      (set! (.-resolve state) resolve)\n                      (set! (.-reject state) reject)))]\n       (specify! obj\n         pt/ICompletable\n         (-resolve! [_ v]\n           (.resolve state v))\n         (-reject! [_ v]\n           (.reject state v))))))\n\n#?(:cljs\n   (defn extend-promise!\n     [t]\n     (extend-type t\n       pt/IPromiseFactory\n       (-promise [p] p)\n\n       pt/IPromise\n       (-map\n         ([it f] (.then it #(f %)))\n         ([it f e] (.then it #(f %))))\n       (-bind\n         ([it f] (.then it #(f %)))\n         ([it f e] (.then it #(f %))))\n       (-catch\n         ([it f] (.catch it #(f %)))\n         ([it f e] (.catch it #(f %))))\n       (-handle\n         ([it f] (.then it #(f % nil) #(f nil %)))\n         ([it f e] (.then it #(f % nil) #(f nil %))))\n       (-finally\n         ([it f] (.then it #(f % nil) #(f nil %)) it)\n         ([it f executor] (.then it #(f % nil) #(f nil %)) it)))))\n\n#?(:cljs\n   (extend-promise! js/Promise))\n\n#?(:clj\n   (extend-protocol pt/IPromise\n     CompletionStage\n     (-map\n       ([it f]\n        (.thenApply ^CompletionStage it\n                    ^Function (pu/->FunctionWrapper f)))\n\n       ([it f executor]\n        (.thenApplyAsync ^CompletionStage it\n                         ^Function (pu/->FunctionWrapper f)\n                         ^Executor (exec/resolve-executor executor))))\n\n     (-bind\n       ([it f]\n        (.thenCompose ^CompletionStage it\n                      ^Function (pu/->FunctionWrapper f)))\n\n       ([it f executor]\n        (.thenComposeAsync ^CompletionStage it\n                           ^Function (pu/->FunctionWrapper f)\n                           ^Executor (exec/resolve-executor executor))))\n\n     (-catch\n       ([it f]\n        (-> ^CompletionStage it\n            (.handle ^BiFunction (pu/->BiFunctionWrapper\n                                  (fn [v e]\n                                    (if e\n                                      (f (unwrap-completion-exception e))\n                                      it))))\n            (.thenCompose ^Function fw-identity)))\n\n       ([it f executor]\n        (-> ^CompletionStage it\n            (.handleAsync ^BiFunction (pu/->BiFunctionWrapper\n                                       (fn [v e]\n                                         (if e\n                                           (f (unwrap-completion-exception e))\n                                           it)))\n                          ^Executor (exec/resolve-executor executor))\n            (.thenCompose ^Function fw-identity))))\n\n     (-handle\n       ([it f]\n        (.handle ^CompletionStage it\n                 ^BiFunction (pu/->BiFunctionWrapper #(f %1 (unwrap-completion-exception %2)))))\n\n       ([it f executor]\n        (.handleAsync ^CompletionStage it\n                      ^BiFunction (pu/->BiFunctionWrapper f #(f %1 (unwrap-completion-exception %2)))\n                      ^Executor (exec/resolve-executor executor))))\n\n     (-finally\n       ([it f]\n        (.whenComplete ^CompletionStage it\n                       ^BiConsumer (pu/->BiConsumerWrapper f)))\n\n       ([it f executor]\n        (.whenCompleteAsync ^CompletionStage it\n                            ^BiConsumer (pu/->BiConsumerWrapper f)\n                            ^Executor (exec/resolve-executor executor))))\n\n     ))\n\n#?(:clj\n   (extend-type CompletableFuture\n     pt/ICancellable\n     (-cancel! [it]\n       (.cancel it true))\n     (-cancelled? [it]\n       (.isCancelled it))\n\n     pt/ICompletable\n     (-resolve! [f v] (.complete f v))\n     (-reject! [f v] (.completeExceptionally f v))\n\n     pt/IState\n     (-extract [it]\n       (try\n         (.getNow it nil)\n         (catch ExecutionException e\n           (.getCause e))\n         (catch CompletionException e\n           (.getCause e))))\n\n     (-resolved? [it]\n       (and (not (.isCompletedExceptionally it))\n            (not (.isCancelled it))\n            (.isDone it)))\n\n     (-rejected? [it]\n       (.isCompletedExceptionally it))\n\n     (-pending? [it]\n       (not (.isDone it)))))\n\n\n\n#?(:clj\n   (extend-protocol pt/IAwaitable\n     Thread\n     (-await\n       ([it] (.join ^Thread it))\n       ([it duration]\n        (if (instance? Duration duration)\n          (.join ^Thread it ^Duration duration)\n          (.join ^Thread it (int duration)))))\n\n     CountDownLatch\n     (-await\n       ([it]\n        (.await ^CountDownLatch it))\n       ([it duration]\n        (if (instance? Duration duration)\n          (.await ^CountDownLatch it (long (inst-ms duration)) TimeUnit/MILLISECONDS)\n          (.await ^CountDownLatch it (long duration) TimeUnit/MILLISECONDS))))\n\n     CompletableFuture\n     (-await\n       ([it] (.get ^CompletableFuture it))\n       ([it duration]\n        (let [ms (if (instance? Duration duration) (inst-ms duration) duration)]\n          (.get ^CompletableFuture it (int ms) TimeUnit/MILLISECONDS))))\n\n     CompletionStage\n     (-await\n       ([it]\n        (pt/-await (.toCompletableFuture ^CompletionStage it)))\n       ([it duration]\n        (pt/-await (.toCompletableFuture ^CompletionStage it) duration)))))\n\n;; --- Promise Factory\n\n;; This code is responsible of coercing the incoming value to a valid\n;; promise type. In some cases we will receive a valid promise object,\n;; in this case we return it as is. This is useful when you want to\n;; `then` or `map` over a plain value that can be o can not be a\n;; promise object\n\n#?(:clj\n   (extend-protocol pt/IPromiseFactory\n     CompletionStage\n     (-promise [cs] cs)\n\n     Throwable\n     (-promise [e]\n       (rejected e))\n\n     Object\n     (-promise [v]\n       (resolved v))\n\n     nil\n     (-promise [v]\n       (resolved v)))\n\n   :cljs\n   (extend-protocol pt/IPromiseFactory\n     js/Error\n     (-promise [e]\n       (rejected e))\n\n     default\n     (-promise [v]\n       (resolved v))))\n\n;; --- Pretty printing\n\n(defn promise->str\n  [p]\n  \"#<Promise[~]>\")\n\n#?(:clj\n   (defmethod print-method java.util.concurrent.CompletionStage\n     [p ^java.io.Writer writer]\n     (let [status (cond\n                    (pt/-pending? p) \"pending\"\n                    (pt/-rejected? p) \"rejected\"\n                    :else \"resolved\")]\n       (.write writer ^String (format \"#object[java.util.concurrent.CompletableFuture 0x%h \\\"%s\\\"]\" (hash p) status)))))\n\n#?(:cljs\n   (extend-type js/Promise\n     IPrintWithWriter\n     (-pr-writer [p writer opts]\n       (-write writer (promise->str p)))))\n"]}